/**
 * Plot Point on canvas
 * @param  {[type]} x        [description]
 * @param  {[type]} y        [description]
 * @param  {[type]} selected [description]
 * @return {[type]}          [description]
 */
function graphyPlotPoint(context, x, y, shape, meta) {
    if (shape == null || shape == 'cross') {
        graphyDrawSolidLine(context, x - 5, y - 5, x + 5, y + 5);
        graphyDrawSolidLine(context, x - 5, y + 5, x + 5, y - 5);
    } else if (shape == 'circle' || shape == 'point') {
        context.beginPath();
        context.arc(x, y, meta.POINT_RAD_PX, 0, 2*Math.PI);
        context.fill();
        context.stroke();
        context.fillStyle = meta.MAIN_COLOR;
        context.strokeStyle = meta.MAIN_COLOR;
    }
}

/**
 * Draw lines on canvas with 2 end points
 * @param  {[type]} context [description]
 * @param  {[type]} start   [description]
 * @param  {[type]} end     [description]
 * @param  {[type]} meta    [description]
 * @return {[type]}         [description]
 */
function graphyDrawLine(context, start, end, meta) {
    var startX = start[0];
    var endX = end[0];
    var startY = start[1];
    var endY = end[1];

    var _x1 = graphyUnitToPixel(startX, 'x', meta);
    var _x2 = graphyUnitToPixel(endX, 'x', meta);
    var _y1 = graphyUnitToPixel(startY, 'y', meta);
    var _y2 = graphyUnitToPixel(endY, 'y', meta);
    graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);
}

/**
 * Function to draw polynomials
 * @param  {[type]} startX [description]
 * @param  {[type]} endX   [description]
 * @param  {[type]} para   [description]
 * @return {[type]}        [description]
 */
function graphyDrawPoly(context, startX, endX, para, meta) {
    if (meta.POLY_SEGMENT <= 0) {
        console.log('Segment is not positive');
        return;
    }

    var prevX = startX;
    var prevY = 0;
    for (var i = 0; i < para.length; i++) {
        var power = para.length - i - 1;
        prevY += para[i] * Math.pow(prevX, power);
    }

    while (prevX < endX) {
        nextX = prevX + meta.POLY_SEGMENT;
        var nextY = 0;
        for (var i = 0; i < para.length; i++) {
            var power = para.length - i - 1;
            nextY += para[i] * Math.pow(nextX, power);
        }

        var _x1 = graphyUnitToPixel(prevX, 'x', meta);
        var _x2 = graphyUnitToPixel(nextX, 'x', meta);
        var _y1 = graphyUnitToPixel(prevY, 'y', meta);
        var _y2 = graphyUnitToPixel(nextY, 'y', meta);
        graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);

        prevX = nextX;
        prevY = nextY;
    }
}

/**
 * Function to draw solid lines
 * @param  {[type]} fromX [description]
 * @param  {[type]} fromY [description]
 * @param  {[type]} toX   [description]
 * @param  {[type]} toY   [description]
 * @return {[type]}       [description]
 */
function graphyDrawSolidLine(context, fromX, fromY, toX, toY, color) {
    context.beginPath();
    context.moveTo(fromX, fromY);
    context.lineTo(toX, toY);
    context.closePath();                
    context.stroke();
    context.strokeStyle = color;
}

/**
 * Function to draw circles
 * @param  {[type]} context [description]
 * @param  {[type]} centerX [description]
 * @param  {[type]} centerY [description]
 * @param  {[type]} radius  [description]
 * @param  {[type]} meta    [description]
 * @return {[type]}         [description]
 */
function graphyDrawCircle(context, centerX, centerY, radius, meta) {
    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2*Math.PI);
    context.stroke();
    context.strokeStyle = meta.MAIN_COLOR;

    context.beginPath();
    context.arc(centerX, centerY, meta.POINT_RAD_PX, 0, 2*Math.PI);
    context.fill();
    context.stroke();
    context.fillStyle = meta.MAIN_COLOR;
    context.strokeStyle = meta.MAIN_COLOR;
}

function graphyDrawSine(context, startX, endX, mag, meta) {
    if (meta.POLY_SEGMENT <= 0) {
        console.log('Segment is not positive');
        return;
    }

    var prevX = startX;
    var prevY = null;
    var nextX = null;
    var nextY = null;

    while (prevX <= endX) {
        prevY = mag * Math.sin(prevX);
        nextX = prevX + meta.POLY_SEGMENT;
        nextY = mag * Math.sin(nextX);

        var _x1 = graphyUnitToPixel(prevX, 'x', meta);
        var _x2 = graphyUnitToPixel(nextX, 'x', meta);
        var _y1 = graphyUnitToPixel(prevY, 'y', meta);
        var _y2 = graphyUnitToPixel(nextY, 'y', meta);
        graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);

        prevX = nextX;
        prevY = nextY;
    }
}

function graphyDrawCosine(context, startX, endX, mag, meta) {
    if (meta.POLY_SEGMENT <= 0) {
        console.log('Segment is not positive');
        return;
    }

    var prevX = startX;
    var prevY = null;
    var nextX = null;
    var nextY = null;

    while (prevX <= endX) {
        prevY = mag * Math.cos(prevX);
        nextX = prevX + meta.POLY_SEGMENT;
        nextY = mag * Math.cos(nextX);

        var _x1 = graphyUnitToPixel(prevX, 'x', meta);
        var _x2 = graphyUnitToPixel(nextX, 'x', meta);
        var _y1 = graphyUnitToPixel(prevY, 'y', meta);
        var _y2 = graphyUnitToPixel(nextY, 'y', meta);
        graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);

        prevX = nextX;
        prevY = nextY;
    }
}

function graphyDrawTangent(context, startX, endX, mag, meta) {
    if (meta.POLY_SEGMENT <= 0) {
        console.log('Segment is not positive');
        return;
    }

    var prevX = startX;
    var prevY = null;
    var nextX = null;
    var nextY = null;

    while (prevX <= endX) {
        prevY = mag * Math.tan(prevX);
        nextX = prevX + meta.POLY_SEGMENT;
        nextY = mag * Math.tan(nextX);

        var _x1 = graphyUnitToPixel(prevX, 'x', meta);
        var _x2 = graphyUnitToPixel(nextX, 'x', meta);
        var _y1 = graphyUnitToPixel(prevY, 'y', meta);
        var _y2 = graphyUnitToPixel(nextY, 'y', meta);
        graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);

        prevX = nextX;
        prevY = nextY;
    }
}

function graphyDrawCotantgent(context, startX, endX, mag, meta) {
    if (meta.POLY_SEGMENT <= 0) {
        console.log('Segment is not positive');
        return;
    }

    var prevX = startX;
    var prevY = null;
    var nextX = null;
    var nextY = null;

    while (prevX <= endX) {
        prevY = mag * Math.cot(prevX);
        nextX = prevX + meta.POLY_SEGMENT;
        nextY = mag * Math.cot(nextX);

        var _x1 = graphyUnitToPixel(prevX, 'x', meta);
        var _x2 = graphyUnitToPixel(nextX, 'x', meta);
        var _y1 = graphyUnitToPixel(prevY, 'y', meta);
        var _y2 = graphyUnitToPixel(nextY, 'y', meta);
        graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);

        prevX = nextX;
        prevY = nextY;
    }
}

function graphyDrawLog(context, base, max, meta) {
    if (meta.POLY_SEGMENT <= 0) {
        console.log('Segment is not positive');
        return;
    }

    var prevX = meta.POLY_SEGMENT;
    var prevY = null;
    var nextX = null;
    var nextY = null;

    var denominator = 1;
    if (base != null && base != 'e') {
        denominator = Math.abs(base);
    }

    while (prevX <= max) {
        prevY = Math.log(prevX) / denominator;
        nextX = prevX + meta.POLY_SEGMENT;
        nextY = Math.log(nextX) / denominator;

        var _x1 = graphyUnitToPixel(prevX, 'x', meta);
        var _x2 = graphyUnitToPixel(nextX, 'x', meta);
        var _y1 = graphyUnitToPixel(prevY, 'y', meta);
        var _y2 = graphyUnitToPixel(nextY, 'y', meta);
        graphyDrawSolidLine(context, _x1, _y1, _x2, _y2, meta.MAIN_COLOR);

        prevX = nextX;
        prevY = nextY;
    }
}
var graphy = function(dom, data) {
    // CONSTANT variable
    var meta = {
        CVS_WIDTH       : 500,
        CVS_HEIGHT      : 500,
        VERTICAL_NAME   : 'y',
        HORIZONTAL_NAME : 'x',
        MAX_X_UNIT      : 5,
        MIN_X_UNIT      : -5,
        MAX_Y_UNIT      : 5,
        MIN_Y_UNIT      : -5,
        INTERVAL_UNIT   : 1,
        MARGIN_PX       : 10,
        PADDING_PX      : 15,
        ARROW_SZ_PX     : 5,
        POINT_RAD_PX    : 2,
        MAIN_COLOR      : "#000",
        POLY_SEGMENT    : 0.1,
        ID              : 'graphy.js_' + Date.now(),
        DIVISION_X      : null,
        DIVISION_Y      : null,
        ORIGIN_X        : null,
        ORIGIN_Y        : null,
    };

    if (data != null) {
        if (data.id) meta.ID = data.id;
        if (data.verticalName) meta.VERTICAL_NAME = data.verticalName;
        if (data.horizontalName) meta.HORIZONTAL_NAME = data.horizontalName;
        if (data.height) meta.CVS_HEIGHT = data.height;
        if (data.width) meta.CVS_WIDTH = data.width;
        if (data.xMax) meta.MAX_X_UNIT = parseInt(data.xMax);
        if (data.xMin) meta.MIN_X_UNIT = parseInt(data.xMin);
        if (data.yMax) meta.MAX_Y_UNIT = parseInt(data.yMax);
        if (data.yMin) meta.MIN_Y_UNIT = parseInt(data.yMin);
        if (data.interval) meta.INTERVAL_UNIT = data.interval;

        // Primary check for data
        if (meta.MAX_X_UNIT < meta.MIN_X_UNIT) {
            console.log("Error: Wrong input for x boundaries");
            return;
        }

        if (meta.MAX_Y_UNIT < meta.MIN_Y_UNIT) {
            console.log("Error: Wrong input for y boundaries");
            return;
        }
    }

    // Canvas Setup
    var canvas = graphySetEmptyCanvas(meta, dom);
    var context = canvas.getContext("2d");
    init();

    /**
     * Initialize Axes
     * @return {[type]} [description]
     */
    function init() {
        // Setup graph metrics
        meta.DIVISION_X = 
            (meta.CVS_WIDTH - 2 * meta.MARGIN_PX - 2 * meta.PADDING_PX) / (meta.MAX_X_UNIT - meta.MIN_X_UNIT);
        meta.DIVISION_Y = 
            (meta.CVS_HEIGHT - 2 * meta.MARGIN_PX - 2 * meta.PADDING_PX) / (meta.MAX_Y_UNIT - meta.MIN_Y_UNIT);
        if (meta.MAX_Y_UNIT > 0 && meta.MIN_Y_UNIT < 0) {
            meta.ORIGIN_Y = meta.MARGIN_PX + meta.PADDING_PX + meta.DIVISION_Y * meta.MAX_Y_UNIT;
        }
        if (meta.MAX_X_UNIT > 0 && meta.MIN_X_UNIT < 0) {
            meta.ORIGIN_X = meta.MARGIN_PX + meta.PADDING_PX + meta.DIVISION_X * Math.abs(meta.MIN_X_UNIT);
        }

        // Draw Axes if necessary
        if (meta.ORIGIN_Y) {
            graphyDrawSolidLine(context, meta.MARGIN_PX, meta.ORIGIN_Y, 
                meta.CVS_WIDTH - meta.MARGIN_PX, meta.ORIGIN_Y, meta.MAIN_COLOR);

            // Draw the arrow head
            graphyDrawSolidLine(context, meta.CVS_WIDTH - meta.MARGIN_PX, meta.ORIGIN_Y, 
                meta.CVS_WIDTH - meta.MARGIN_PX - meta.ARROW_SZ_PX, meta.ORIGIN_Y - meta.ARROW_SZ_PX);
            graphyDrawSolidLine(context, meta.CVS_WIDTH - meta.MARGIN_PX, meta.ORIGIN_Y, 
                meta.CVS_WIDTH - meta.MARGIN_PX - meta.ARROW_SZ_PX, meta.ORIGIN_Y + meta.ARROW_SZ_PX);
            context.fillText(
                meta.HORIZONTAL_NAME, meta.CVS_WIDTH - meta.MARGIN_PX, meta.ORIGIN_Y - meta.MARGIN_PX
                );
        }
        if (meta.ORIGIN_X) {
            graphyDrawSolidLine(context, meta.ORIGIN_X, meta.MARGIN_PX, meta.ORIGIN_X, 
                meta.CVS_HEIGHT - meta.MARGIN_PX, meta.MAIN_COLOR);

            // Draw the arrow head
            graphyDrawSolidLine(context, meta.ORIGIN_X, meta.MARGIN_PX, 
                meta.ORIGIN_X - meta.ARROW_SZ_PX, meta.MARGIN_PX + meta.ARROW_SZ_PX, meta.MAIN_COLOR);
            graphyDrawSolidLine(context, meta.ORIGIN_X, meta.MARGIN_PX, 
                meta.ORIGIN_X + meta.ARROW_SZ_PX, meta.MARGIN_PX + meta.ARROW_SZ_PX, meta.MAIN_COLOR);
            context.fillText(
                meta.VERTICAL_NAME, meta.ORIGIN_X + meta.MARGIN_PX, meta.MARGIN_PX
                );
        }
        context.fillText(0, meta.ORIGIN_X + 5, meta.ORIGIN_Y + 15);

        // Draw the intervals
        for (var i = meta.MIN_X_UNIT; i <= meta.MAX_X_UNIT; i += meta.INTERVAL_UNIT) {
            if (i != 0) {
                var _x = meta.MARGIN_PX + meta.PADDING_PX + (i - meta.MIN_X_UNIT) * meta.DIVISION_X;
                graphyDrawSolidLine(context, _x, meta.ORIGIN_Y + 5, _x, meta.ORIGIN_Y - 5, meta.MAIN_COLOR);
                context.fillText(i, _x, meta.ORIGIN_Y + 15);
            }
        }
        for (var i = meta.MAX_Y_UNIT; i >= meta.MIN_Y_UNIT; i -= meta.INTERVAL_UNIT) {
            if (i != 0) {
                var _y = meta.MARGIN_PX + meta.PADDING_PX + (meta.MAX_Y_UNIT - i) * meta.DIVISION_Y;
                graphyDrawSolidLine(context, meta.ORIGIN_X - 5, _y, meta.ORIGIN_X + 5, _y, meta.MAIN_COLOR);
                context.fillText(i, meta.ORIGIN_X + 5, _y + 5);
            }
        }
    }

    // Public Object APIs
    return {
        point: function(x, y, shape) {
            if (x != null && y != null) {
                var _x = graphyUnitToPixel(x, 'x', meta);
                var _y = graphyUnitToPixel(y, 'y', meta);
                if (shape === 'cross') {
                    graphyPlotPoint(context, _x, _y, meta.MAIN_COLOR, 'circle');
                } else {
                    graphyPlotPoint(context, _x, _y, meta.MAIN_COLOR);
                }
            }
        },
        line: function(start, end) {
            if (start != null && end != null) {
                graphyDrawLine(context, start, end, meta);
            }
        },
        poly: function(para, rangeX) {
            if (para != null) {
                var startX = meta.MIN_X_UNIT;
                var endX = meta.MAX_X_UNIT;
                if (rangeX) {
                    if (rangeX[0] && startX < rangeX[0]) {
                        startX = rangeX[0];
                    }
                    if (rangeX[1] && endX > rangeX[1]) {
                        endX = rangeX[1];
                    }
                }

                graphyDrawPoly(context, startX, endX, para, meta);
            }
        },
        circle: function(point, radius) {
            if (point != null && radius != null) {
                if (point[0] != null && point[1] != null) {
                    var _centerX = graphyUnitToPixel(point[0], 'x', meta);
                    var _centerY = graphyUnitToPixel(point[1], 'y', meta);
                    var _radius = radius * meta.DIVISION_X;
                    graphyDrawCircle(context, _centerX, _centerY, _radius, meta);
                }
            }
        },
        sin: function(mag, rangeX) {
            if (mag != null) {
                var startX = meta.MIN_X_UNIT;
                var endX = meta.MAX_X_UNIT;
                if (rangeX) {
                    if (rangeX[0] && startX < rangeX[0]) {
                        startX = rangeX[0];
                    }
                    if (rangeX[1] && endX > rangeX[1]) {
                        endX = rangeX[1];
                    }
                }

                graphyDrawSine(context, startX, endX, mag, meta);
            }
        },
        cos: function(mag, rangeX) {
            if (mag != null) {
                var startX = meta.MIN_X_UNIT;
                var endX = meta.MAX_X_UNIT;
                if (rangeX) {
                    if (rangeX[0] && startX < rangeX[0]) {
                        startX = rangeX[0];
                    }
                    if (rangeX[1] && endX > rangeX[1]) {
                        endX = rangeX[1];
                    }
                }

                graphyDrawCosine(context, startX, endX, mag, meta);
            }
        },
        tan: function(mag, rangeX) {
            if (mag != null) {
                var startX = meta.MIN_X_UNIT;
                var endX = meta.MAX_X_UNIT;
                if (rangeX) {
                    if (rangeX[0] && startX < rangeX[0]) {
                        startX = rangeX[0];
                    }
                    if (rangeX[1] && endX > rangeX[1]) {
                        endX = rangeX[1];
                    }
                }

                graphyDrawTangent(context, startX, endX, mag, meta);
            }
        },
        cot: function(mag, rangeX) {
            if (mag != null) {
                var startX = meta.MIN_X_UNIT;
                var endX = meta.MAX_X_UNIT;
                if (rangeX) {
                    if (rangeX[0] && startX < rangeX[0]) {
                        startX = rangeX[0];
                    }
                    if (rangeX[1] && endX > rangeX[1]) {
                        endX = rangeX[1];
                    }
                }

                graphyDrawTangent(context, startX, endX, mag, meta);
            }
        },
        log: function(base, max) {
            if (max == null || max < 0 || max > meta.MAX_X_UNIT) {
                max = meta.MAX_X_UNIT;
            }

            graphyDrawLog(context, base, max, meta);
        }
    }
}
function graphyUnitToPixel(unit, direction, meta) {
    unit = parseFloat(unit);
    if (direction === 'x') {
        return meta.MARGIN_PX + meta.PADDING_PX + (unit - meta.MIN_X_UNIT) * meta.DIVISION_X;
    } else if (direction === 'y') {
        return meta.MARGIN_PX + meta.PADDING_PX + (meta.MAX_Y_UNIT - unit) * meta.DIVISION_Y;
    } else {
        console.log('Direction is not defined');
    }
}

/**
 * Set empty canvas
 */
function graphySetEmptyCanvas(meta, dom) {
    var _canvas = document.getElementById(meta.ID);
    if (_canvas == null) {
        _canvas = graphyCreateElement('canvas', meta.ID, null, '', dom);
    }

    _canvas.width = meta.CVS_WIDTH;
    _canvas.height = meta.CVS_HEIGHT;
    _canvas.style.border = '1px solid lightgray';
    _canvas.getContext("2d").font = "12px verdana";
    return _canvas;
}

/**
 * Create new element, with info, and append to parent.
 * @param  {String} _dom       Dom element tag name
 * @param  {String} _id        ID field
 * @param  {String} _classname Class field
 * @param  {String} _html      Inner HTML field
 * @param  {DOM}    _parent    Parent DOM
 * @return {DOM}               Newly created DOM
 */
function graphyCreateElement(dom, id, classname, html, parent) {
    var _dom = document.createElement(dom);
    if (id != null) {
        _dom.id = id;
    }
    if (classname != null) {
        _dom.className = classname;
    }
    if (html != null) {
        _dom.innerHTML = html;
    }
    if (parent != null) {
        parent.appendChild(_dom);
    }
    return _dom;
}